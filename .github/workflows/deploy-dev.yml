name: Deploy App to Dev Server

on:
  push:
#  paths: ['envs/testing/settings.yml', 'envs/testing/deployment.yml']
  repository_dispatch:
    types: [pr-merged-to-main]

permissions:
  contents: write

jobs:
  get_env_vars_from_repo:
    runs-on: ubuntu-latest

    outputs:
      domain: ${{ steps.dev_specific_variables.outputs.domain }}
      environment: ${{ steps.dev_specific_variables.outputs.environment }}
      aws_zone: ${{ steps.dev_specific_variables.outputs.aws_zone }}
      ssl_cert_directory: ${{ steps.base_variables.outputs.ssl_cert_directory }}
      ssl_key_directory: ${{ steps.base_variables.outputs.ssl_key_directory }}
      ssl_acme_directory: ${{ steps.base_variables.outputs.ssl_acme_directory }}

    env:
      BASE_SETTINGS_FILE: ./base/settings.yml
      ENV_SETTINGS_FILE: settings.yml
      DEV_SETTINGS_FOLDER: ./envs/testing

    steps:
      - name: setup yq
        uses: mikefarah/yq@master

      - name: checkout repo
        uses: actions/checkout@v4

      - name: output specific env variables
        id: dev_specific_variables
        run: |
          BASE_DOMAIN=$(yq '.deployment.domain' $BASE_SETTINGS_FILE)
          cd $DEV_SETTINGS_FOLDER
          SUB_DOMAIN=$(yq '.specifics | load(.deployment) | .app.subdomain' $ENV_SETTINGS_FILE)
          if [[ ! -z $SUB_DOMAIN ]]; then
            SUB_DOMAIN="$SUB_DOMAIN."
          fi
          echo "domain=${SUB_DOMAIN}${BASE_DOMAIN}" >> "$GITHUB_OUTPUT"
          ENVIRONMENT=$(yq '.specifics | load(.deployment) | .app.environment' $ENV_SETTINGS_FILE)
          echo "environment=$ENVIRONMENT" >> "$GITHUB_OUTPUT"
          AWS_ZONE=$(yq '.app.aws-zone' deployment.yml)
          echo "aws_zone=$AWS_ZONE" >> "$GITHUB_OUTPUT"

      - name: output base env variables
        id: base_variables
        run: |
          CERT_DIRECTORY=$(yq '.deployment.ssl.directories.cert' $BASE_SETTINGS_FILE)
          KEY_DIRECTORY=$(yq '.deployment.ssl.directories.key' $BASE_SETTINGS_FILE)
          ACME_CHALLENGE_DIRECTORY=$(yq '.deployment.ssl.directories.acme-challenge' $BASE_SETTINGS_FILE)
          echo "ssl_cert_directory=$CERT_DIRECTORY" >> "$GITHUB_OUTPUT"
          echo "ssl_key_directory=$KEY_DIRECTORY" >> "$GITHUB_OUTPUT"
          echo "ssl_acme_directory=$ACME_CHALLENGE_DIRECTORY" >> "$GITHUB_OUTPUT"

  Get_EC2_IP:
    runs-on: ubuntu-latest
    needs: [get_env_vars_from_repo]

    outputs:
      ec2-ip: ${{ steps.get-ip.outputs.EC2_IP }}

    # This is required for requesting the JWT from AWS
    permissions:
      id-token: write
      contents: read
    
    env:
      AWS_ZONE: ${{ needs.get_env_vars_from_repo.outputs.aws_zone }}

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_ZONE }}
          role-to-assume: arn:aws:iam::822477694772:role/Github-Actions

      - name: get ec2 ip
        id: get-ip
        run: |
          EC2_IP=$(aws --region "$AWS_ZONE" \
          ec2 describe-instances --filters \
          "Name=instance-state-name, Values=running" \
          "Name=instance-id, Values=${{ secrets.EC2_INSTANCE_ID_DEV }}" \
          --query "Reservations[*].Instances[*].[PublicIpAddress]" \
          --output text)
          echo "EC2_IP=$EC2_IP" >> "$GITHUB_OUTPUT"

  EC2-Deploy:
    runs-on: ubuntu-latest
    needs: [get_env_vars_from_repo, Get_EC2_IP]

    # For this deploy to work correctly, the EC2 instance needs to have docker and docker-compose installed
    # Then make sure the docker daemon is running
    # Also make sure to create a docker group on the EC2 instance before running docker commands, otherwise
    # the EC2 instance won't have permissions for those docker commands (without using sudo for linux)

    outputs:
      build: ${{ steps.version-outputs.outputs.BUILD }}
      version: ${{ steps.version-outputs.outputs.VERSION }}

    # This is required for requesting the JWT from AWS
    permissions:
      id-token: write
      contents: read

    env:
      ENV_CONFIG_PATH: envs/testing/
      ENV_CONFIG_FILE: settings.yml
      APP_REPO_CHECKOUT_PATH: app
      EC2_USERNAME: ${{ secrets.EC2_USERNAME_DEV }}
      EC2_IP: ${{ needs.Get_EC2_IP.outputs.ec2-ip }}
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      SSL_CERT_DIRECTORY: ${{ needs.get_env_vars_from_repo.outputs.ssl_cert_directory }}
      SSL_KEY_DIRECTORY: ${{ needs.get_env_vars_from_repo.outputs.ssl_key_directory }}
      SSL_ACME_DIRECTORY: ${{ needs.get_env_vars_from_repo.outputs.ssl_acme_directory }}
      DOMAIN: ${{ needs.get_env_vars_from_repo.outputs.domain }}
      SSH_KEY: ${{ secrets.DEV_SSH_PRIVATE_KEY }}

    steps:
      - name: setup yq
        uses: mikefarah/yq@master

      - name: checkout repo
        uses: actions/checkout@v4

      - name: checkout app repo file
        uses: actions/checkout@v4
        with:
          repository: "Kojolika/Portfolio"
          path: ${{ env.APP_REPO_CHECKOUT_PATH }}
          ref: "main"

      - name: get port and protocol settings
        run: |
          cd $ENV_CONFIG_PATH
          echo -n "PORT=" >> "$GITHUB_ENV" && yq 'load(.resources[0]) | .deployment.ports.port' $ENV_CONFIG_FILE >> "$GITHUB_ENV"
          echo -n "AWS_ZONE=" >> "$GITHUB_ENV" && yq '.specifics | load(.deployment) | .app.aws-zone' $ENV_CONFIG_FILE >> "$GITHUB_ENV"

      - name: get build and verison number
        run: |
          cd $ENV_CONFIG_PATH
          IMAGE=$(yq 'load(.specifics.version) | .spec.containers[] | select(.app-name == "portfolio") | .image' $ENV_CONFIG_FILE)
          echo -n "IMAGE=" >> "$GITHUB_ENV" && echo "$IMAGE" >> "$GITHUB_ENV"
          if [[ -z $(echo "$IMAGE" | grep -P -o "[0-9]+\.[0-9]+\.[0-9]+\-[0-9]+") ]]; then
              if [ ! "$IMAGE" = "latest"]; then
                exit 1;
              fi
            ACCESS_TOKEN=$(curl https://hub.docker.com/v2/users/login -d "username=$DOCKER_USERNAME" -d "password=$DOCKER_PASSWORD" | yq '.token')
            echo "::add-mask::$ACCESS_TOKEN"
            REPO_RESULTS=$(curl https://hub.docker.com/v2/namespaces/myshoka/repositories/portfolio/tags -H "Authorization: Bearer $ACCESS_TOKEN")
            echo "::add-mask::$REPO_RESULTS"
            LATEST_SHA=$(echo "$REPO_RESULTS" | image="$IMAGE" yq '.results[] | select(.name == env(image)) | .digest')
            echo "::add-mask::$LATEST_SHA"
            LATEST_VERSION=$(echo "$REPO_RESULTS" | latest_sha="$LATEST_SHA" image="$IMAGE" yq '.results[] | select(.digest == env(latest_sha) and .name != env(image)) | .name')
            echo "::add-mask::$LATEST_VERSION"

            echo -n "VERSION=" >> "$GITHUB_ENV" && echo "$LATEST_VERSION" |  grep -P -o "[0-9]+\.[0-9]+\.[0-9]+" >> "$GITHUB_ENV"
            echo -n "BUILD=" >> "$GITHUB_ENV" && echo "$LATEST_VERSION" |  grep -P -o "(?<=\-)[0-9]+" >> "$GITHUB_ENV"
          else
            echo -n "VERSION=" >> "$GITHUB_ENV" && echo "$IMAGE" |  grep -P -o "[0-9]+\.[0-9]+\.[0-9]+" >> "$GITHUB_ENV"
            echo -n "BUILD=" >> "$GITHUB_ENV" && echo "$IMAGE" |  grep -P -o "(?<=\-)[0-9]+" >> "$GITHUB_ENV"
          fi

      - name: add version and build to job outputs
        id: version-outputs
        run: |
          echo "VERSION=$VERSION" >> "$GITHUB_OUTPUT"
          echo "BUILD=$BUILD" >> "$GITHUB_OUTPUT"

      - name: hide EC2 ip
        run: |
          echo "::add-mask::$EC2_IP"

      - name: set ssh identity on github runner
        env:
          SSH_PRIVATE_KEY_FILE: id_rsa
        run: |
          SSH_DIR=~/.ssh
          mkdir -p $SSH_DIR
          chmod 700 $SSH_DIR
          cd $SSH_DIR
          ssh-keyscan $EC2_IP > known_hosts
          echo "$SSH_KEY" > $SSH_PRIVATE_KEY_FILE
          chmod 600 *
          eval `ssh-agent -s`
          ssh-add ${SSH_DIR}/${SSH_PRIVATE_KEY_FILE}

      - name: set env variables for docker-compose
        env:
          DOCKER_REPO: ${{ secrets.DOCKER_REPO_URL }}
          ENVIRONMENT: ${{ needs.get_env_vars_from_repo.outputs.environment }}
          DOMAIN_EMAIL: ${{ secrets.DOMAIN_EMAIL }}
        run: |
          cd $APP_REPO_CHECKOUT_PATH
          echo "ENVIRONMENT=$ENVIRONMENT" >> .env
          echo "NODE_ENV=$ENVIRONMENT" >> .env
          echo "PORT=$PORT" >> .env
          echo "AWS_ZONE=$AWS_ZONE" >> .env
          echo "BUILD=${VERSION}+${BUILD}" >> .env
          echo "LATEST_IMAGE=${DOCKER_REPO}:${IMAGE}" >> .env
          echo "DOMAIN=${DOMAIN}" >> .env
          echo "DOMAIN_EMAIL=${DOMAIN_EMAIL}" >> .env
          echo "SSL_CERT_DIRECTORY=${SSL_CERT_DIRECTORY}" >> .env
          echo "SSL_KEY_DIRECTORY=${SSL_KEY_DIRECTORY}" >> .env
          echo "SSL_ACME_DIRECTORY=${SSL_ACME_DIRECTORY}" >> .env

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
            aws-region: ${{ needs.get_env_vars_from_repo.outputs.aws_zone }}
            role-to-assume: arn:aws:iam::822477694772:role/Github-Actions

      - name: Get ssl cert and key from AWS
        env:
          AWS_SECRET_KEY_SSL_CERT_DEV: ${{ secrets.AWS_SECRET_KEY_SSL_CERT_DEV }}
          AWS_SECRET_KEY_SSL_KEY_DEV: ${{ secrets.AWS_SECRET_KEY_SSL_KEY_DEV }}
        run: |
          cd $APP_REPO_CHECKOUT_PATH
          SSL_KEY=$(aws secretsmanager get-secret-value --secret-id portfolio/dev/ssl_key | \
          grep -o -P '(?<="SecretString": "{\\"'"${AWS_SECRET_KEY_SSL_KEY_DEV}"'\\":\\")(?!\\"}",)[^\\]*')
          SSL_CERT=$(aws secretsmanager get-secret-value --secret-id portfolio/dev/ssl_cert | \
          grep -o -P '(?<="SecretString": "{\\"'"${AWS_SECRET_KEY_SSL_CERT_DEV}"'\\":\\")(?!\\"}",)[^\\]*')
          if [ ! -d ${SSL_CERT_DIRECTORY} ]; then
            sudo mkdir -p ${SSL_CERT_DIRECTORY}
          fi
          if [ ! -d ${SSL_KEY_DIRECTORY} ]; then
            sudo mkdir -p ${SSL_KEY_DIRECTORY}
          fi
          sudo chown ${USER} ${SSL_CERT_DIRECTORY}
          sudo chown ${USER} ${SSL_KEY_DIRECTORY}
          echo "$SSL_CERT" > ${SSL_CERT_DIRECTORY}/${DOMAIN}.crt
          echo "$SSL_KEY" > ${SSL_KEY_DIRECTORY}/${DOMAIN}.key

      - name: run commands on ec2 through ssh
        env:
          EC2_CONTEXT: ec2
        run: |
          cd $APP_REPO_CHECKOUT_PATH
          docker context create $EC2_CONTEXT --docker "host=ssh://${EC2_USERNAME}@${EC2_IP}"
          docker context use $EC2_CONTEXT
          echo "$DOCKER_PASSWORD" | docker login -u $DOCKER_USERNAME --password-stdin
          docker-compose down
          docker system prune -a -f
          docker-compose up -d
          docker compose push nginx

      - name: check if both containers are running
        # We subtract 1 since we're counting the lines of the stdin, the first line is the table header
        run: |
          NUM_CONTAINERS=$(($(docker ps | wc -l) - 1))
          if(( NUM_CONTAINERS < 2 )); then
            exit 1;
          fi
  
  Verify_HTTPS:
    runs-on: ubuntu-latest
    needs: [EC2-Deploy, Get_EC2_IP, get_env_vars_from_repo]

    # This is required for requesting the JWT from AWS
    permissions:
      id-token: write

    steps:
      - name: Check if HTTPS is configured correctly
        uses: appleboy/ssh-action@v1.0.3
        id: https_verified
        env:           
          EC2_USERNAME: ${{ secrets.EC2_USERNAME_DEV }}
          EC2_IP: ${{ needs.Get_EC2_IP.outputs.ec2-ip }}
          SSH_KEY: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
          SSL_CERT_DIRECTORY: ${{ needs.get_env_vars_from_repo.outputs.ssl_cert_directory }}
        with:
          host: ${{ env.EC2_IP }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.SSH_KEY }}
          script: |
            IS_HTTPS_SETUP=$(cat <<'EOF' | docker exec -i app_nginx_1 /bin/bash
            if true | openssl s_client -connect $DOMAIN:443 2>/dev/null | \
            openssl x509 -noout -checkend 0 && openssl verify ${{ env.SSL_CERT_DIRECTORY }}/$DOMAIN.crt; then
              HTTPS_SETUP='true'
            else
              HTTPS_SETUP='false'
            fi
            echo "$HTTPS_SETUP"
            EOF
            )
            echo "HTTPS_SETUP=$IS_HTTPS_SETUP" >> "$GITHUB_OUTPUT"

      - name: create new cert and key
        uses: appleboy/ssh-action@v1.0.3
        if: ${{ steps.https_verified.outputs.HTTPS_SETUP == 'false' }}
        id: get_cert_and_key
        env:
          INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID_DEV }}
          DOMNAIN: ${{ needs.get_env_vars_from_repo.outputs.domain }}
          DOMAIN_EMAIL: ${{ secrets.DOMAIN_EMAIL }}
          SSL_CERT_DIRECTORY: ${{ needs.get_env_vars_from_repo.outputs.ssl_cert_directory }}
          SSL_KEY_DIRECTORY: ${{ needs.get_env_vars_from_repo.outputs.ssl_key_directory }}
          SSL_ACME_DIRECTORY: ${{ needs.get_env_vars_from_repo.outputs.ssl_acme_directory }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME_DEV }}
          EC2_IP: ${{ needs.Get_EC2_IP.outputs.ec2-ip }}
          SSH_KEY: ${{ secrets.DEV_SSH_PRIVATE_KEY }}
          ENVIRONMENT: ${{ needs.get_env_vars_from_repo.outputs.environment }}
          TOKEN: ${{ secrets.PAT_UPDATE_SSL_CERTS_AND_KEYS }}
        with:
          host: ${{ env.EC2_IP }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.SSH_KEY }}
          # regarding use of getssl, typically we would need to specify the domain name but 
          # since out docker container has DOMAIN set as an env,
          # due to how getssl is written, we dont need to specify it
          script: |
            CERT_AND_KEY=$(cat <<'EOF' | docker exec -i app_nginx_1 /bin/bash
            rm ${{ env.SSL_CERT_DIRECTORY }}/${DOMAIN}.crt
            rm ${{ env.SSL_KEY_DIRECTORY }}/${DOMAIN}.key
            apt-get update
            apt-get -y install dnsutils
            cd ~
            curl --silent https://raw.githubusercontent.com/srvrco/getssl/latest/getssl > getssl
            chmod 700 getssl
            ./getssl -c
            SSL_CONFIG=~/.getssl/getssl.cfg
            SSL_DOMAIN_SPECIFIC_CONFIG=~/.getssl/${DOMAIN}/getssl.cfg
            sed -i -E "s/#ACCOUNT_EMAIL=\"[^\"]*\"/ACCOUNT_EMAIL=\"${{ env.DOMAIN_EMAIL }}\"/" $SSL_CONFIG
            if [[ ${{ env.ENVIRONMENT }} = 'production' ]]; then
              sed -i 's/CA="https://acme-staging-v02.api.letsencrypt.org"/#CA="https://acme-staging-v02.api.letsencrypt.org"/' $SSL_CONFIG
              sed -i 's/#CA="https://acme-v02.api.letsencrypt.org"/CA="https://acme-v02.api.letsencrypt.org"/' $SSL_CONFIG
            fi
            sed -i -E "s/#USE_SINGLE_ACL=\"[^\"]*\"/USE_SINGLE_ACL=\"true\"/" $SSL_DOMAIN_SPECIFIC_CONFIG
            sed -i -E "s/SANS=\"[^\"]*\"/SANS=\"\"/" $SSL_DOMAIN_SPECIFIC_CONFIG
            sed -i -E "s/#RELOAD_CMD=\"[^\"]*\"/RELOAD_CMD=\"\/etc\/init.d\/nginx reload\"/" $SSL_DOMAIN_SPECIFIC_CONFIG
            SSL_CERT_DIRECTORY=${{ env.SSL_CERT_DIRECTORY }}
            SSL_KEY_DIRECTORY=${{ env.SSL_KEY_DIRECTORY }}
            SSL_ACME_DIRECTORY=${{ env.SSL_ACME_DIRECTORY }}
            sed -i -E "s/#ACL=\(.*/ACL=(\"${SSL_ACME_DIRECTORY//\//\\\/}\")/" $SSL_DOMAIN_SPECIFIC_CONFIG
            sed -i -E "s/#DOMAIN_CERT_LOCATION=\"[^\"]*\"/DOMAIN_CERT_LOCATION=\"${SSL_CERT_DIRECTORY//\//\\\/}\"/" $SSL_DOMAIN_SPECIFIC_CONFIG
            sed -i -E "s/#DOMAIN_KEY_LOCATION=\"[^\"]*\"/DOMAIN_KEY_LOCATION=\"${SSL_KEY_DIRECTORY//\//\\\/}\"/" $SSL_DOMAIN_SPECIFIC_CONFIG
            ./getssl
            echo "SSL_KEY=$(cat ${{ env.SSL_CERT_DIRECTORY }}/$DOMAIN.key)"
            echo "SSL_CERT=$(cat ${{ env.SSL_CERT_DIRECTORY }}/$DOMAIN.crt)"
            EOF
            )
            SSL_KEY=$(echo "$CERT_AND_KEY" | grep -o -P "(?<=SSL_KEY=).*")
            SSL_CERT=$(echo "$CERT_AND_KEY" | grep -o -P "(?<=SSL_CERT=).*")
            echo "SSL_KEY=$SSL_KEY" >> "$GITHUB_OUTPUT"
            echo "SSL_CERT=$SSL_CERT" >> "$GITHUB_OUTPUT"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: ${{ steps.https_verified.outputs.HTTPS_SETUP == 'false' }}
        with:
          aws-region: ${{ needs.get_env_vars_from_repo.outputs.aws_zone }}
          role-to-assume: arn:aws:iam::822477694772:role/Github-Actions

      - name: update AWS secrets
        if: ${{ steps.https_verified.outputs.HTTPS_SETUP == 'false' }}
        env:
          SSL_KEY: ${{ steps.get_cert_and_key.outputs.SSL_KEY }}
          SSL_CERT: ${{ steps.get_cert_and_key.outputs.SSL_CERT }}
        run: |
          aws secretsmanager \
          put-secret-value \
          --secret-id portfolio/dev/ssl_key \
          --secret-string $SSL_KEY
          aws secretsmanager \
          put-secret-value \
          --secret-id portfolio/dev/ssl_cert \
          --secret-string $SSL_CERT


  Set-Version-In-Repo:
    runs-on: ubuntu-latest
    needs: EC2-Deploy

    env:
      VERSION_CONFIG: envs/testing/version.yml
      BRANCH: main

    steps:
      - name: setup yq
        uses: mikefarah/yq@master

      - name: checkout repo
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            ${{ env.VERSION_CONFIG }}
          sparse-checkout-cone-mode: false
      
      - name: update version and build if outdated
        run: |
          CURRENT_VERSION=$(yq '.app-version' ${{ env.VERSION_CONFIG }})
          CURRENT_BUILD=$(yq '.build' ${{ env.VERSION_CONFIG }})
          HAS_FILE_BEEN_UPDATED="false"
          if [[ ! "$CURRENT_VERSION" = "$VERSION" ]]; then
            version=$VERSION yq -i '.app-version = env(version)' ${{ env.VERSION_CONFIG }}
            HAS_FILE_BEEN_UPDATED="true"
          fi
          if [[ ! $CURRENT_BUILD -eq $BUILD ]]; then
            build=$BUILD yq -i '.build = env(build)' ${{ env.VERSION_CONFIG }}
            HAS_FILE_BEEN_UPDATED="true"
          fi
          if [[ "$HAS_FILE_BEEN_UPDATED" = "true" ]]; then
            git config --global user.email ${{ secrets.ACTIONS_COMMIT_EMAIL}}
            git config --global user.name ${{ secrets.ACTIONS_COMMIT_NAME }}
            git add ${{ env.VERSION_CONFIG }}
            git commit -m "Set version according to image via Github Actions"
            git push origin $GITHUB_REF_NAME
          fi

        env:
          BUILD: ${{ needs.EC2-Deploy.outputs.build }}
          VERSION: ${{ needs.EC2-Deploy.outputs.version }}
